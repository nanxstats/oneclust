[{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"oneclust implements maximum homogeneity clustering (partitioning) method univariate data described Fisher (1958) via dynamic programming. Given one-dimensional numerical vector \\((a_1, a_2, \\ldots, a_n)\\), weight vector \\((w_1, w_2, \\ldots, w_n)\\), positive integer \\(k < n\\), algorithm seeks minimize \\[ D = \\sum_{= 1}^{n} w_i (a_i - \\bar{a_i})^2 \\] \\(a_i\\) assigned \\(k\\) clusters. \\(\\bar{a_i}\\) weighted mean cluster \\(a_i\\) belongs . Fisher proved optimal partitions contiguous. Contiguous means \\(< j < k\\), \\(a_i\\) \\(a_k\\) assigned cluster, \\(a_j\\) must also assigned cluster — otherwise partition suboptimal. fact leads substantially reduced number possible partitions dynamic programming solutions. Intuitively, maximum homogeneity clustering can used smooth data reveal structures. potential applications data pre-processing post-processing statistical machine learning.","code":""},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"feature-engineering-for-high-cardinality-categorical-features","dir":"Articles","previous_headings":"","what":"Feature engineering for high-cardinality categorical features","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"Categorical features high cardinality rare levels pose common challenge building certain types supervised learning models. example, classification trees might able handle limited number levels categorical predictors, binary node split categorical feature \\(l\\) levels means finding one \\(2^{l-1}\\) possible combinations thus computationally intractable. tackle problem, Breiman et al. (1984) discussed splitting categorical feature two subsets response binary, generalized Fisher’s result arbitrary convex node impurity functions. Lightgbm (G. Ke et al. 2017) employs method find optimal split sorting histogram based training objective. , besides one-hot encoding hashing, recoding high-cardinality categorical features histogram sorting maximum homogeneity partitioning viable feature engineering strategy practice. application also limited tree models.","code":""},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"simulated-postal-code-data","dir":"Articles","previous_headings":"Feature engineering for high-cardinality categorical features","what":"Simulated postal code data","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"section, simulate high-cardinality variable binary response. key assumption : probabilities response correlate size level. data generated, use maximum homogeneity clustering (sorted) histogram categorical variable. goal verify clustering results can uncover level size structure potentially help classification modeling later. example derived “rare levels” vignette vtreat package (Zumel Mount 2016). Generate training set independent test set: categorical variable 500 (unique) levels postal codes. training test set 100,000 samples. level size follows log normal distribution \\(LN(\\log(4000), 1)\\). postal code levels fewer 3,000 samples, defined “rare levels” probability 0.2 get response label 1. Otherwise, level probability 0.1 getting response label 1. rest samples get response label 0.","code":"library(\"oneclust\") df_levels <- sim_postcode_levels(nlevels = 500, seed = 42) train <- sim_postcode_samples(df_levels, n = 100000, threshold = 3000, prob = c(0.2, 0.1), seed = 43) test <- sim_postcode_samples(df_levels, n = 100000, threshold = 3000, prob = c(0.2, 0.1), seed = 44) head(df_levels) #>    size postcode #> 1 15756   z04113 #> 2  2274   z04578 #> 3  5751   z02580 #> 4  7532   z01457 #> 5  5993   z03546 #> 6  3597   z04056 head(train) #>   postcode label is_rare #> 1   z04546     0   FALSE #> 2   z03223     0   FALSE #> 3   z01687     0   FALSE #> 4   z01301     0    TRUE #> 5   z00848     0   FALSE #> 6   z03046     0   FALSE head(test) #>   postcode label is_rare #> 1   z01482     1   FALSE #> 2   z03825     1   FALSE #> 3   z02533     0   FALSE #> 4   z03640     1   FALSE #> 5   z01608     1   FALSE #> 6   z02130     0   FALSE"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"recode-the-training-set","dir":"Articles","previous_headings":"Feature engineering for high-cardinality categorical features","what":"Recode the training set","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"training set, cluster postal codes 32 clusters size level (histogram): postal codes belong first five clusters higher probability (approximately 0.2) getting label 1. clusters lower probability (around 0.1) getting label 1:  can also verify number samples first five clusters close actual number samples “rare levels”: specified number clusters \\(k\\) smaller, results might good though.","code":"k <- 32 level_hist <- table(train$postcode) level_new <- oneclust(level_hist, k)$cluster feature_tr_levels <- as.character(1:k) feature_tr <- as.character(level_new[match(train$postcode, names(level_hist))]) feature_tr <- ordered(feature_tr, levels = feature_tr_levels) op <- par(las = 1) plot(feature_tr, train$label, lty = 0, xlab = \"Cluster\", ylab = \"Label\") abline(h = 0.2, col = cud(1)) abline(h = 0.1, col = cud(2)) par(op) sum(train$is_rare) #> [1] 10496 sum(table(feature_tr)[1:5]) #> [1] 9693"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"recode-the-test-set","dir":"Articles","previous_headings":"Feature engineering for high-cardinality categorical features","what":"Recode the test set","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"practice, encode postal codes test set cluster labels used training set, classification models can correctly applied test set. Check recoded variable similar label pattern:","code":"feature_te <- as.character(level_new[match(test$postcode, names(level_hist))]) feature_te <- ordered(feature_te, levels = feature_tr_levels) op <- par(las = 1) plot(feature_te, test$label, lty = 0, xlab = \"Cluster\", ylab = \"Label\") abline(h = 0.2, col = cud(1)) abline(h = 0.1, col = cud(2)) par(op) sum(test$is_rare) #> [1] 10610 sum(table(feature_te)[1:5]) #> [1] 9883"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"grouping-coefficients-in-regression-models","dir":"Articles","previous_headings":"","what":"Grouping coefficients in regression models","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"Besides sparsity properties, homogeneity estimated coefficients linear regressions important property — meaning certain groups variables encouraged share coefficients (Z. T. Ke, Fan, Wu 2015). source homogeneity attributed systematic similarities variables, example, financial assets belong sector, sets adjacent variables strong spatial correlation (Lin et al. 2017).","code":""},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"simulated-regression-data","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Simulated regression data","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"use fused lasso regression model simulated data illustrate potential application post-processing coefficients. example derived vignette genlasso package (Tibshirani, Taylor, et al. 2011).","code":"set.seed(42) n <- 100 i <- 1:n y <- (i > 20 & i < 30) + 5 * (i > 50 & i < 70) + rnorm(n, sd = 0.1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"raw-estimates","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Raw estimates","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"","code":"# # If genlasso is available: # out <- genlasso::fusedlasso1d(y) out <- readRDS(\"out.rds\") # beta1 <- coef(out, lambda = 1.5)$beta beta1 <- readRDS(\"beta1.rds\") plot(beta1) abline(h = 0)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"soft-thresholding","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Soft-thresholding","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"can use soft-thresholding transform raw coefficient estimates zero non-zero values:","code":"# beta2 <- genlasso::softthresh(out, lambda = 1.5, gamma = 1) beta2 <- readRDS(\"beta2.rds\") grp <- as.integer(beta2 != 0) + 1L plot(beta2, col = cud(grp)) abline(h = 0) legend(\"topleft\", legend = c(\"Zero\", \"Non-zero\"), col = cud(unique(grp)), pch = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"clustering-k-2","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Clustering (k = 2)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"can also use maximum homogeneity clustering method group coefficients two clusters:","code":"cl1 <- oneclust(beta1, k = 2)$cluster plot(beta1, col = cud(cl1)) abline(h = 0) legend(\"topleft\", legend = paste(\"Cluster\", unique(cl1)), col = cud(unique(cl1)), pch = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"clustering-k-3","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Clustering (k = 3)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"needed, can increase \\(k\\) get groups coefficients:","code":"cl2 <- oneclust(beta1, k = 3)$cluster plot(beta1, col = cud(cl2)) abline(h = 0) legend(\"topleft\", legend = paste(\"Cluster\", unique(cl2)), col = cud(unique(cl2)), pch = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"clustering-while-preserving-data-order-k-5","dir":"Articles","previous_headings":"Grouping coefficients in regression models","what":"Clustering while preserving data order (k = 5)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"sorted data clustering previous examples. Since data strong spatial correlation, may need preserve order data points clustering . called “restricted problem” Fisher (1958). solve problems, use sort = FALSE:","code":"cl3 <- oneclust(beta1, k = 5, sort = FALSE)$cluster plot(beta1, col = cud(cl3)) abline(h = 0) legend(\"topleft\", legend = paste(\"Cluster\", unique(cl3)), col = cud(unique(cl3)), pch = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"sequential-data-peak-calling-and-segmentation","dir":"Articles","previous_headings":"","what":"Sequential data peak calling and segmentation","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"sequential data time series data, algorithm might useful peak calling segmentation.","code":""},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"simulated-time-series-data","dir":"Articles","previous_headings":"Sequential data peak calling and segmentation","what":"Simulated time series data","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"use example pracma::findpeaks():","code":"x <- seq(0, 1, len = 1024) pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81) hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2) wdt <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)  psignal <- numeric(length(x)) for (i in seq(along = pos)) {   psignal <- psignal + hgt[i] / (1 + abs((x - pos[i]) / wdt[i]))^4 }  plot(psignal, type = \"l\")"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"peak-calling-k-2","dir":"Articles","previous_headings":"Sequential data peak calling and segmentation","what":"Peak calling (k = 2)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"Group signal two clusters:  Cluster 2 covers peak locations — method specify single data point peak, instead, finds intervals.","code":"cl <- oneclust(psignal, k = 2) plot(psignal, type = \"h\", col = cud(cl$cluster)) legend(\"topright\", legend = paste(\"Cluster\", unique(cl$cluster)), col = cud(unique(cl$cluster)), lty = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"peak-calling-k-4","dir":"Articles","previous_headings":"Sequential data peak calling and segmentation","what":"Peak calling (k = 4)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"increase \\(k\\), fewer intervals included peak cluster (Cluster 4), narrower peak intervals:  One may also use parameter w oneclust() use weighted version algorithm amplify signal.","code":"cl <- oneclust(psignal, k = 4) plot(psignal, type = \"h\", col = cud(cl$cluster + 2)) legend(\"topright\", legend = paste(\"Cluster\", unique(cl$cluster)), col = cud(unique(cl$cluster + 2)), lty = 1)"},{"path":"https://nanx.me/oneclust/articles/oneclust.html","id":"segmentation-k-6","dir":"Articles","previous_headings":"Sequential data peak calling and segmentation","what":"Segmentation (k = 6)","title":"Maximum Homogeneity Clustering for One-Dimensional Data","text":"segmentation, respect order data:","code":"cl <- oneclust(psignal, k = 6, sort = FALSE) plot(psignal, type = \"h\", col = cud(cl$cluster)) legend(\"topright\", legend = paste(\"Cluster\", unique(cl$cluster)), col = cud(unique(cl$cluster)), lty = 1, cex = 0.8)"},{"path":[]},{"path":"https://nanx.me/oneclust/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nan Xiao. Author, maintainer.","code":""},{"path":"https://nanx.me/oneclust/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Xiao N (2024). oneclust: Maximum Homogeneity Clustering Univariate Data. R package version 0.3.0, https://github.com/nanxstats/oneclust, https://nanx./oneclust/.","code":"@Manual{,   title = {oneclust: Maximum Homogeneity Clustering for Univariate Data},   author = {Nan Xiao},   year = {2024},   note = {R package version 0.3.0, https://github.com/nanxstats/oneclust},   url = {https://nanx.me/oneclust/}, }"},{"path":"https://nanx.me/oneclust/index.html","id":"oneclust-","dir":"","previous_headings":"","what":"Maximum Homogeneity Clustering for Univariate Data","title":"Maximum Homogeneity Clustering for Univariate Data","text":"Implements maximum homogeneity clustering algorithm one-dimensional data described W. D. Fisher (1958) <doi:10.1080/01621459.1958.10501479> via dynamic programming. Check vignette(\"oneclust\") applications feature engineering, regression modeling, peak calling.","code":""},{"path":"https://nanx.me/oneclust/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Maximum Homogeneity Clustering for Univariate Data","text":"can install oneclust CRAN: try development version GitHub:","code":"install.packages(\"oneclust\") remotes::install_github(\"nanxstats/oneclust\")"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://nanx.me/oneclust/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Maximum Homogeneity Clustering for Univariate Data","text":"oneclust free open source software, licensed GPL-3.","code":""},{"path":"https://nanx.me/oneclust/reference/cud.html","id":null,"dir":"Reference","previous_headings":"","what":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","title":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","text":"Masataka Okabe Kei Ito's Color Universal Design palette","code":""},{"path":"https://nanx.me/oneclust/reference/cud.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","text":"","code":"cud(x, shift = TRUE, reverse = FALSE)"},{"path":"https://nanx.me/oneclust/reference/cud.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","text":"x Vector, color index. shift Start second color CUD palette? reverse Reverse color order?","code":""},{"path":"https://nanx.me/oneclust/reference/cud.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","text":"vector color hex values.","code":""},{"path":"https://nanx.me/oneclust/reference/cud.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Masataka Okabe and Kei Ito's Color Universal Design palette — cud","text":"","code":"barplot(rep(1, 7), col = cud(1:7))  barplot(rep(1, 8), col = cud(1:8, shift = FALSE))  barplot(rep(1, 8), col = cud(1:8, shift = FALSE, reverse = TRUE))"},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum homogeneity clustering for one-dimensional data — oneclust","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"Maximum homogeneity clustering one-dimensional data","code":""},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"","code":"oneclust(x, k, w = NULL, sort = TRUE)"},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"x Numeric vector, samples clustered. k Integer, number clusters. w Numeric vector, sample weights (optional). Note weights sampling weights (example, certain proportion population), frequency weights (example, number occurrences). sort sort x (w) clustering? Default TRUE. Otherwise order data respected.","code":""},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"list containing: cluster - cluster id sample. cut - index optimal cut points.","code":""},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"Fisher, Walter D. 1958. Grouping Maximum Homogeneity. Journal American Statistical Association 53 (284): 789--98.","code":""},{"path":"https://nanx.me/oneclust/reference/oneclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum homogeneity clustering for one-dimensional data — oneclust","text":"","code":"set.seed(42) x <- sample(c(   rnorm(50, sd = 0.2),   rnorm(50, mean = 1, sd = 0.3),   rnorm(100, mean = -1, sd = 0.25) )) oneclust(x, 3) #> $cluster #>   [1] 3 1 3 2 1 1 1 3 2 3 2 2 3 1 1 1 1 1 2 1 1 1 1 1 2 3 2 2 1 1 1 2 1 1 1 3 1 #>  [38] 1 3 1 3 2 1 1 3 2 3 2 1 1 3 3 1 2 3 3 1 1 1 1 3 3 1 1 1 1 1 3 2 2 2 2 2 1 #>  [75] 1 2 3 2 1 2 1 3 2 3 1 2 3 1 3 1 1 2 1 1 2 3 3 1 2 3 2 3 1 1 2 1 3 1 1 1 1 #> [112] 3 1 1 1 1 1 3 1 2 2 1 1 2 1 1 2 2 2 1 2 1 2 1 3 2 2 1 3 3 2 2 2 1 1 3 1 1 #> [149] 3 1 2 3 2 3 1 3 1 2 1 1 2 3 1 2 2 3 2 1 1 3 3 1 1 1 1 3 1 3 1 3 1 2 3 2 1 #> [186] 3 1 1 1 1 1 1 1 1 1 2 3 3 1 1 #>  #> $cut #> [1]   1 101 152 #>"},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"Simulate levels sizes high-cardinality feature","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"","code":"sim_postcode_levels(nlevels = 100L, seed = 1001)"},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"nlevels Number levels generate. seed Random seed.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"data frame postal codes sizes.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"code derived example described \"rare levels\" vignette vtreat package.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate the levels and their sizes in a high-cardinality feature — sim_postcode_levels","text":"","code":"df_levels <- sim_postcode_levels(nlevels = 500, seed = 42) head(df_levels) #>    size postcode #> 1 15756   z04113 #> 2  2274   z04578 #> 3  5751   z02580 #> 4  7532   z01457 #> 5  5993   z03546 #> 6  3597   z04056"},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"Simulate high-cardinality feature binary response","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"","code":"sim_postcode_samples(   df_levels,   n = 2000L,   threshold = 1000,   prob = c(0.3, 0.1),   seed = 1001 )"},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"df_levels Number levels. n Number samples. threshold threshold determining postal code rare. prob Occurrence probability vector class 1 event rare non-rare postal codes. seed Random seed.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"data frame samples postal codes, response labels, level rarity status.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"code derived example described \"rare levels\" vignette vtreat package.","code":""},{"path":"https://nanx.me/oneclust/reference/sim_postcode_samples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a high-cardinality feature and a binary response — sim_postcode_samples","text":"","code":"df_levels <- sim_postcode_levels(nlevels = 500, seed = 42) df_postcode <- sim_postcode_samples(   df_levels,   n = 10000, threshold = 3000, prob = c(0.2, 0.1), seed = 43 ) head(df_postcode) #>   postcode label is_rare #> 1   z03139     0   FALSE #> 2   z01208     0   FALSE #> 3   z04309     0    TRUE #> 4   z00303     0   FALSE #> 5   z03428     0   FALSE #> 6   z01759     0   FALSE"},{"path":[]},{"path":"https://nanx.me/oneclust/news/index.html","id":"improvements-0-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"oneclust 0.3.0","text":"Remove magrittr package Imports. result, magrittr pipe long re-exported oneclust. change makes oneclust use minimal sufficient number dependencies. Update code examples vignette use meaningful intermediate variable names instead relying pipe operator.","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"oneclust-023","dir":"Changelog","previous_headings":"","what":"oneclust 0.2.3","title":"oneclust 0.2.3","text":"CRAN release: 2023-03-06","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"improvements-0-2-3","dir":"Changelog","previous_headings":"","what":"Improvements","title":"oneclust 0.2.3","text":"Clarify documentation weights sampling weights instead frequency weights (thanks, @krzysztof-pankow, #3). Improve document style following tidyverse style guide.","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"oneclust-022","dir":"Changelog","previous_headings":"","what":"oneclust 0.2.2","title":"oneclust 0.2.2","text":"CRAN release: 2022-08-15","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"improvements-0-2-2","dir":"Changelog","previous_headings":"","what":"Improvements","title":"oneclust 0.2.2","text":"Use dependencies (genlasso) conditionally vignettes. Fix clang14 warning using bitwise | boolean operands. Remove LazyData field DESCRIPTION fix check note.","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"oneclust-021","dir":"Changelog","previous_headings":"","what":"oneclust 0.2.1","title":"oneclust 0.2.1","text":"CRAN release: 2020-09-01","code":""},{"path":"https://nanx.me/oneclust/news/index.html","id":"improvements-0-2-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"oneclust 0.2.1","text":"Reset graphical parameters changing vignette.","code":""},{"path":[]},{"path":"https://nanx.me/oneclust/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"oneclust 0.2.0","text":"Add argument sort oneclust() support solving restricted clustering problem (preserving data order).","code":""},{"path":[]},{"path":"https://nanx.me/oneclust/news/index.html","id":"new-features-0-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"oneclust 0.1.0","text":"First public release.","code":""}]
